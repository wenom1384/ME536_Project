# -*- coding: utf-8 -*-
"""ME536_Assignment13_Tetris_1818046.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I9CbxEsEQotN3h-dZ5ji382-vYCRIjmx

# **NAME**: HASAN CAN ÖZDEN
## Student **ID**: 1818046

*by providing my name and number I decleare that I have neither provide any help to others nor got help from others*
"""



"""# What to submit?

You are to submit 2 files submitting this files:
```
1234567.py
1234567.ipynb
```

where ```1234567``` is your student ID number.  

You can add as many functions as needed and your test codes can remain in these documents, however, note that I will only call the ```TetrisNext()``` function, therefore, DO NOT change the way ```TetrisNext()``` function is called. In other words, **do not change** the arguments in this function. 

I expect the ```.py``` file so that I can run automated tests on them, and I exptect ```.ipynb``` file which should also act you **assignment report** where you explain your algorithm in detail using proper mathematical terms, associate them with the code, provide references at end etc. Your report should be **clear** but not lost in unnecessary details. Provide a list of references that you used in solving this assignment.
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np

from enum import Enum

from matplotlib import pyplot as plt
# %matplotlib inline
# also import the matrix printing function
!rm bug_numpy_utils.py
!wget https://raw.githubusercontent.com/bugrakoku/bug_python_utils/main/bug_numpy_utils.py
from bug_numpy_utils import MatPrint
from bug_numpy_utils import MatImshow
import time
print('done with importing necessary stuff')

"""# TetrisNext() function - **the** function  

This function takes board current situation $\mathbf{M}_{board}$ and piece to place $\mathbf{p}_{f given}$ and returns  appropriate index numbers $(i,j)$ and return piece $\mathbf{p}_{f returned}$. Since tetris piece don't have to be placed as given to function. Therefore returned $\mathbf{p}_{f returned}$ could be the rotated version of $\mathbf{p}_{fgiven}$. Therefore $\mathbf{p}_{fgiven}$ will not be necesarly equal to the $\mathbf{p}_{freturned}$.

This function returns index numbers $(i,j)$ following two basic rules of tetris

*   There will not be overlapping 
*   Piece cannot be placed overhanging ( piece should be on the top of another piece or bottom of the board) obeying gravitational rules.

---
Since there are many alternatives to place to piece to board obeying two basic rules of tetris. There is function called in "***goodness***" that evalutes each alternatives and rate them. Based on rating of the alternatives TetrisNext() function return best alternative among others. Therefore "***goodness***" function can be considered as some kind of  ***heuristic function***.

##**Goodness( )** Function - Heuristic Function

This function takes board situation $\mathbf{M}_{board}$, piece $\mathbf{p}_{f}$ and index numbers $\mathbf{(i,j)}$ to place this piece to this board and returns a number called **goodness number**. This number is some kind of rating that represent fitting goodness of the piece to the board. There are **four** fundamental criteria that contribute overall rating. That are given below.

* **Fitting goodness** based on surrouding of the given piece. This rating is based on numbers of occupying neighbours around the given piece when it is placed to given index $\mathbf{(i,j)}$. Not every neighbour have same importance. Therefore there is a matrix called $\mathbf{M}_{mask}$ specifying importance of indivual neighbours.

* Fitting goodness amplified when there are rows can be popped. There is multiplier called "**CARPAN**" which is initally "0", however, if there are lines to pop when that indivual piece placed to an specified index this variable increased. For example lets assume there are two alternatives of index couples that yield same fitting goodness numbers however one of them pops one lines whereas other one pops nothing. In this case, **CARPAN** variable comes into play and forces to algorithm to select one that pops more line.

* There is one more modifier for rating that favors the index numbers that increases least the **overall height** of the board.

* There is **penalty** for the index numbers that adds up -1000 points to rating of that indivual selection which makes any cell unreachable. 


Considering the four criteria Goodness function returns a number which is rating of that selection. 

"""

def goodness(pf,M,index2place):
  h,w = pf.shape

  i,j=index2place

  Ms=np.copy(M) #Copying the current situation of the board for further use
  ######################## Padding to the board in four edges.
  M2=np.zeros((1,Ms.shape[1])) 
  M1=np.append(M2,Ms,axis=0)
  M3=np.ones((M1.shape[0],1))
  M1=np.append(M3,M1,axis=1)
  M1=np.append(M1,np.ones((M1.shape[0],1)),axis=1)
  M1=np.append(M1,np.ones((1,M1.shape[1])),axis=0)
  ############################################### End of the padding
  j=j+1# index numbers are increased by 1 cause of padding 
  i=i+1
  ###############################################
  M_eski=np.copy(M1) #Copying the current situation of the board for further use

  ############ In the below section piece is placed to the board.
  for x in range(h):
      for y in range(w):
        if pf[x,y]==1:
          #MatPrint(pf)
          M1[i+x, j+y] = pf[x,y]
  ##############################################################
  
  
  ########### Checks for the number of rows to pop after placing the piece
  carpan=0
  for count in range(M1.shape[0]):
    if np.sum(M1[count,:])==M1.shape[1]:
      carpan=carpan+1
  #print(f'carpan is {carpan}')
  ########################################################################

  
  ####################### In the below section evaluation of unreachable cells are done before and after adding the piece
  # If the numbers of the unreachable cells is increased after adding the piece penalty is set to -10000 or -20000
  numberofPenaltytoobad=0
  numberofPenaltybad=0
  for don1 in range(M1.shape[0]-1):
    for don2 in range(M1.shape[1]-1):
      if M_eski[don1+1,don2+1]==0 and M_eski[don1,don2+1]==1 and  M_eski[don1+1,don2+2]==1 and M_eski[don1+1,don2]==1:
        numberofPenaltytoobad=numberofPenaltytoobad+1
      if M_eski[don1+1,don2+1]==0 and M_eski[don1,don2+1]==1 and (M_eski[don1,don2+2]==1 or M_eski[don1,don2]==1):
        numberofPenaltybad=numberofPenaltybad+1

  numberofPenaltytoobad_yeni=0
  numberofPenaltybad_yeni=0
  for don1 in range(M1.shape[0]-1):
    for don2 in range(M1.shape[1]-1):
      if M1[don1+1,don2+1]==0 and M1[don1,don2+1]==1 and  M1[don1+1,don2+2]==1 and M1[don1+1,don2]==1 :
        numberofPenaltytoobad_yeni=numberofPenaltytoobad_yeni+1
      if M1[don1+1,don2+1]==0 and M1[don1,don2+1]==1 and (M1[don1,don2+2]==1 or M1[don1,don2]==1):
        numberofPenaltybad_yeni=numberofPenaltybad_yeni+1
  penalty=0
  if not numberofPenaltytoobad==numberofPenaltytoobad_yeni  and  carpan<2:
    penalty=penalty-20000
  if not numberofPenaltybad==numberofPenaltybad_yeni and  carpan<2:
    penalty=penalty-10000
  #############################################################################################################
 
 
  #################### M_g is the matrix of placed piece with its neigbours.
  M_gg=np.copy(M1)
  M_g=M_gg[i-1:i+h+1,j-1:j+w+1]
  goodness=0
  M_g[M_g<1]=-1
  #########################################################################


 
  ######################### M_mask is generated in the below which is importance matrix that determines the importance 
  #of the cells in the M_g matrix
  M_mask=np.ones((M_g.shape[0],M_g.shape[1]))
  costt=1
  for xx in range(pf.shape[0]):
    costt=costt+(1/M_g.shape[0])
    for yy in range(pf.shape[1]):
      if pf[xx,yy]==0:
        M_mask[xx+1,yy+1]=costt
      #if pf[xx,yy]==0 and xx==(pf.shape[0]-1):
        #M_mask[xx+1,yy+1]=costt*2  
  #######################################################################################
  #print(M_g)
  #print(M_mask)



  ############### Goodness is evaluated in the below section multpliying the M mask and M_g 
  M_multplied=np.multiply(M_g,M_mask)
  #for c in range(M_multplied.shape[0]):
    #goodness=goodness+((np.sum(M_multplied[c,:]))*((c+1)/M_multplied.shape[0]))
  #print(M_multplied)
  goodness=np.sum(M_multplied)
  ####################################################


  ######## height effectiveness is calculated in the below section 
  sattop=[]
  satmask=np.linspace(0,2,M1.shape[0])
  for sat in range(M1.shape[0]):
    sattop=np.append(sattop,np.sum(M1[sat,:]))
  #MatPrint(M1)
  #print(f'Satır Toplamları {sattop}')
  #print(f'Satır Maskesi {satmask}')
  he_ef=np.multiply(sattop,satmask)
  #print(he_ef)
  he_eff=np.sum(he_ef)
  #########################################################



  #overall rating is returned as given below.
  return np.average(goodness)+(abs(np.average(goodness))*carpan)+he_eff+penalty

def TetrisNext(M, piece2place, FollowingPieces = [], debugMode = False):
    '''
    M a numpy array representing the current state of the board
    
    piece2place is a numpy array that represents the current piece
    
    FollowingPieces is a list of the pieces to follow, where each piece is a numpy array 
    If the game continues regularly, FollowingPieces[0] is the next piece to come.
    Note that, if FollowingPieces preview is not available, caller might not pass anything,
    hence, its default value is []

    debugMode is as usual

    Function returns: pf, i2p
    where pf is a numpy array which is the rotated version of piece2place by
    either of the angles: 0, 90, 180, 270
    and i2p is a tuple and contains the indices where pf will be located in M.
    If piece2place cannot be located in any way in M, returns i2p = (-1,-1)
    
    The function that calls TetrisNext most probably do someting as follows:
    pf, i2p = TetrisNext(M, p2p, FP)
    h,w = pf.shape
    i,j = i2p
    M[i:i+h, j:j+w] = pf

    or on a single line

    M[i2p[0]:i2p[0]+pf.shape[0], i2p[1]:i2p[1]+pf.shape[1]] = pf
    '''
    # properly complete the rest
    pf=piece2place
    i2p=(-1,-1)# if it can find an other index number returns this value.
    index=M.shape[0]
    #pflist generated where the rotated versions of the given piece is formed.
    pflist=(pf,np.rot90(pf),np.rot90(np.rot90(pf)),np.rot90(np.rot90(np.rot90(pf))))
    
    goodlist=[]#list of ratings of the indivual selections.
    indexlist=[]#list of indivual selections of the index
    pfshapelist=[]#list of shapes of the indivual selections.
    #print(pflist)
    h,w = pf.shape
    #limit
    for rot,pf in enumerate(pflist): # four alternatives of the rotated version are tested
      h,w = pf.shape # since shapes changes h and w are uptated.
      
      for i in reversed(range(M.shape[0]-h+1)):# starting from bottom to top
        for j in range(M.shape[1]-w+1):#starting from left to right 
           
          if np.sum(np.multiply(M[i:i+h, j:j+w],pf))==0:# checking for overlapping if not go 
            #print(i)
            #print(h)
            #print(M.shape[0])


            ############ this section is checking touching rule 
            if not i+h==M.shape[0]:
              touchingrule=np.multiply(M[i+h, j:j+w],pf[-1,:])
            else:
              touchingrule=[1,1,1]
            if any(touchingrule) or i==(M.shape[0]-1):
              i2p=i,j
            #################################################### 
              good=goodness(pf,M,i2p) # since piece can be placed according to tetris rules # goodness is checked.
              #print(good)
              goodlist.append(good) # goodness is appended to goodlist
              indexlist.append((i,j))# index selection is stored
              pfshapelist.append(pf) # piece shape is stored.
      if goodlist:# if there is selection
        goodindex=goodlist.index(max(goodlist)) # select the max rating.
        pf=pfshapelist[goodindex]# select the shape that corresponds max rating.
        i2p=indexlist[goodindex] # select the index that corresponds the max rating.
    #print(indexlist)


  
    return pf, i2p 
    #for i in range(M.shape[0]):
      #if not np.sum(M[i,:])==0:
        #index=i
        #break
    #print(index)      
    #i2p=index-pf.shape[0],0
    
    #pf = None
    #i2p = (-1,-1)

    #return pf, i2p



"""# Supplementary functions and test code

Please add any supplementary code below so that the first implemented function in your submitted code is ```TetrisNext()```

I have not tested the following code.  
It is here to give an idea... If it does not work, get the inspriation, fix it, and game on...
"""

# for example let's generate a library of pieces with the very basics

Pieces = []
Pieces.append( np.ones((4,1)) )
Pieces.append( np.array([ [1,1,1], [1,0,0] ]) )
Pieces.append( np.array([ [1,1,1], [0,1,0] ]) )
Pieces.append( np.array([ [1,1,0], [0,1,1] ]) )

for piece in Pieces:
    MatPrint(piece, 'Piece')

# a single call for testing
H,W = 20, 10
M = np.zeros((H,W)) # empty board
nPreview = 3 # let's assume 3 piece preview
PP = [] # list of preview items
for i in range(nPreview+1): # fill in the list randomly with +1 that represents the piece2place
    PP.append( Pieces[np.random.randint(0, len(Pieces))] )
pf, i2c = TetrisNext(M, PP.pop(), PP )

# which can easily be generalized for a full game, 
# hints of what I plan to do is given, cod is not complete

# similarly prepare the game
H,W = 20, 10
M = np.zeros((H,W)) # empty board
Mcolored = np.zeros((H,W))
nPreview = 2 # number of pieces in the preview, 0 does not make sense though, if you want to test without preview, simply do not send FollowingPieces argument
PP = [] # list of preview items
for i in range(nPreview+1): # fill in the list randomly with +1 that represents the piece2place
    PP.append( Pieces[np.random.randint(0, len(Pieces))] )

i,j = (0,0) # make sure we enter the while loop
N =10 # let's start with shorter games
nPopLines = 0 # number of lines popped
gameScore = 0 # well, game score

while N > 0 : #  positive is a good sign to continue
    N = N -1 # decrement loop counter till it expires to finish the game
    #MatPrint(PP[0])
    pf, i2c = TetrisNext(M, PP.pop(0), PP)
    if i2c==(-1,-1):
      break
    #MatPrint(pf)
    # now that PP is one less, append a random piece to it
    PP.append( Pieces[np.random.randint(0, len(Pieces))])
    i,j = i2c 
    h,w = pf.shape
    #print(i,j)
    color=np.random.randint(100,255)
    for x in range(h):
      for y in range(w):
        if pf[x,y]==1:
          #MatPrint(pf)
          M[i+x, j+y] = pf[x,y]
          Mcolored[i+x, j+y] = pf[x,y]*color
          
    # we will most probably have a test function to test if what you return makes sense?
    #MatPrint(M)
    for cc in range(M.shape[0]):
      
      if np.sum(M[cc,:])==M.shape[1]:
        #print('SILDIMMMMMM')
        gameScore=gameScore+1
        plt.figure()
        plt.imshow(Mcolored,cmap='inferno')
        M=np.delete(M,cc,0)
        Mcolored=np.delete(Mcolored,cc,0)
        #M=np.concatenate((np.zeros((0,M.shape[1])),M),axis=0)
        #Mcolored=np.concatenate((np.zeros((0,M.shape[1])),Mcolored),axis=0)
        M=np.append(np.zeros((1,M.shape[1])),M,axis=0)
        Mcolored=np.append(np.zeros((1,M.shape[1])),Mcolored,axis=0)
        
    plt.figure()
    plt.imshow(Mcolored,cmap='inferno')
     
    
    # if so
    # check if i,j is negative, do whatever necessary, does it mean game over?
    # if not check if the game is over, if so update the score and break the loop

    # if not check if there are lines to pop, and update running score

print(f'{N} pieces left with a total of {gameScore} points ')
#plt.figure()
#plt.imshow(Mcolored,cmap='inferno')